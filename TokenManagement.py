from datetime import datetime
import hashlib
import json
from os.path import isfile

########################################################################
# Ecxeptions
########################################################################

class TokenException(Exception) :
    def __init__(self, token : str):
        self._token = token
        return super().__init__()

    def getErrorString(self) :
        return f"Token \"{self._token}\" is not valid"

class InvalidUsernameException(Exception) :
    def __init__(self, username : str):
        self._username = username
        return super().__init__()

    def getErrorString(self) :
        return f"Username \"{self._username}\" is not valid"

class InvalidTokenUsernamePairException(InvalidUsernameException, TokenException) :
    def __init__(self, username, token):
        InvalidUsernameException.__init__(self, username)
        TokenException.__init__(self, token)

    def getErrorString(self) :
        return f"The given token is invalid for user: \"{self._username}\""

########################################################################
# Token Manager
########################################################################

class TokenManager :
    """
        Manager for valid tokens.
        Loads the valid tokens from an encrypted local file, decrypts the tokens file
        Provides API for determining if a token is valid
    """
    def __init__(self, filepath) :
        self._filepath = filepath

        self._tokens : dict = {}

        if isfile(filepath) :
            # TODO: encrypt and decrypt tokens file
            with open(filepath, "r") as file :
                contents = file.read()

            # Tokens are a map from username to token
            self._tokens : dict = json.loads(contents)

        return super().__init__()

    # Returns true if there is an entry for the given token
    def isValidToken(self, token) -> bool :
        return token in self._tokens.values()

    # Get the username associated with the given token
    # raises a TokenException is the token is not valid
    def getUsername(self, token) -> str :
        for key, value in self._tokens.items() :
            if value == token :
                return key

        raise TokenException(token)

    # Throws an exception of the appropriate type if the token and username do not match
    def validateUsernameAndToken(self, username, token) :
        if not username in self._tokens :
            raise InvalidUsernameException(username) 

        if self._tokens[username] != token :
            raise InvalidTokenUsernamePairException(username, token)

    # Write the current tokens to the file we read them from initially
    def commitTokens(self) :
        asString = json.dumps(self._tokens)

        with open(self._filepath, "w") as file :
            file.write(asString)

########################################################################
# Owned Token Manager
########################################################################

class NonOwnedTokenManager(TokenManager) :
    """
        Token Manager where tokens can be added that were generated by a different API
    """
    def setToken(self, user : str,  token : str) :
        self._tokens[user] = token
        self.commitTokens()

    def getToken(self, user : str) -> str : 
        return self._tokens.get(user)

    def getAllUsers(self) -> list :
        return self._tokens.keys()

########################################################################
# Owned Token Manager
########################################################################

class OwnedTokenManager(TokenManager) :
    """
        Token Manager with the added functionality to generate tokens
    """
    # Generates a token based on the given username and the current time
    # using SHA3 hashing algorithm.
    # Adds the new token as the token for the given user.
    # Be sure that this is called in a secure way, exposing this could allow forgery of tokens
    def generateToken(self, username) -> str :
        now = datetime.now().strftime("%d/%m/%Y %H:%M:%S")
        stringToHash = username + now

        hash = hashlib.sha3_512()
        hash.update(stringToHash.encode('utf-8'))
        token = hash.hexdigest()

        self._tokens[username] = token
        self.commitTokens()
        return token

########################################################################
# Multithreaded Owned Token Manager
########################################################################

class MultiThreadedOwnedTokenManager(OwnedTokenManager) :
    """
        Owned Token Manager that locks resources when writing to them and checks the lock when reading them
    """
    def __init__(self, filepath):
        self._lock = threading.Lock()

        with self._lock :
            super().__init__(filepath)

    def isValidToken(self, token) -> bool :
        with self._lock :
            return super().isValidToken(token)

    def getUsername(self, token) -> str :
        with self._lock :
            return super().getUsername(token)

    def validateUsernameAndToken(self, username, token) :
        with self._lock :
            return super().validateUsernameAndToken(username, token)

    def generateToken(self, username) -> str :
        with self._lock :
            return super().generateToken(username)

    def commitTokens(self) :
        with self._lock :
            return super().generateToken()







